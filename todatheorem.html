# Proving Toda's Theorem: \(\text{PH} \subseteq \text{P}^\text{#P}\)

The purpose of this post is to describe an odd complexity class, \(\oplus \text{P}\) (pronounced parity-P), which wasn't known to be powerful or even useful until the discovery of Toda's theorem (which I'm going to prove). Toda's theorem claims that the computational power of the polynomial hierarchy (the set of all problems that can be solved in polynomial time, irrespective of other resources) is completely equal to the ability to count polynomially long things. This is a cool result because it highlights the intricate value of being able to count things - the ability to count allows you to also solve any problem in the polynomial hierarchy.

I'm going to start by defining \(\text{NP}, \text{BPP}\), and \(\oplus \text{P}\) in terms of computational paths. Specifically, a language \(L\) is in:

1) \(\text{NP}\) iff there is such a polynomial-time nondeterministic Turing Machine \(M\) for which \(ğ’™ âˆˆ ğ‘³\) implies that at least one of the computation paths accepts, and \(ğ’™ âˆ‰ ğ‘³\) implies that no computation paths accept.

2) \(\text{BPP}\) iff there is such a polynomial-time nondeterministic Turing Machine \(M\) for which \(x âˆˆ L\) implies that at least \(\frac{2}{3}\) of the computation paths accept, and \(ğ’™ âˆ‰ ğ‘³\) implies that at most \(\frac{1}{3}\) of the computation paths accept.

3) \(\oplus \text{P}\) iff there is such a polynomial-time nondeterministic Turing Machine \(M\) for which \(x âˆˆ L\) implies that an odd number of the computation paths accept, and \(ğ’™ âˆ‰ ğ‘³\) implies that an even number of the computation paths accept.


Next, I'm going to describe the notion of Turing Machines with Oracles, and the specific classes of problems they solve. For instance, consider the classes \(\text{NP}^A\), \(\text{BPP}^A\), \((\oplus \text{P})^A\). These are the classes obtained by replacing the polynomial-time nondeterministic Turing Machine \(M\) in the definitions above with a polynomial-time nondeterministic oracle Turing Machine \(M\) that is equipped with language \(A\) as its oracle. As usual, if we write \(C\) instead of \(A\) in the exponent, for some complexity class \(C\), we mean that any language \(A âˆˆ C\) is permitted as the oracle. If \(C\) has a complete language (as \(\text{NP}^A\) and \((\oplus \text{P})^ğ‘¨\) do, for any oracle \(A\)), then by using that language as the oracle we can solve any instance of a problem in \(C\) with a single call to this specific oracle.

Finally, I'm going to describe the polynomial-time hierarchy. Define \(\Delta_0^P := \Sigma_0^P := \Pi_0^P:= \text{P}\), where \(\text{P}\) is the set of problems that can be solved in polynomial time (with respect to the size of the instance of the problem). Then, for all \(i \geq 0\), define:

$$\Delta_{i+1}^P:=\text{P}^{\Sigma_i^P}$$
$$\Sigma_{i+1}^P:=\text{NP}^{\Sigma_i^P}$$
$$\Pi_{i+1}^P:=\text{coNP}^{\Sigma_i^P}$$

The polynomial-time hierarchy is defined as

$$PH = \bigcup\limits_{i} \{\Delta_i^P, \Sigma_i^P, \Pi_i^P\}$$

The result that I want to show here is that every language in the polynomial hierarchy can be solved by Turing Machines of the counting complexity class \(\text{P}^{\#\text{P}}\) (pronounced P sharp-P), which really illuminates the significance of counting as a fundamental computational resource.



## **Lemma 1: Generalization of the Valiant-Vazirani Theorem to show that \(\text{NP}^A \subseteq \text{BPP}^{(\bigoplus P^A)}\) for any oracle \(A\).**

The generalized Valiant-Vazirani theorem states that for any \(n\), there is a randomized procedure that runs in \(poly(n)\) time and outputs a \(poly(n)\)-size circuit \(C\) such that for each subset \(T\subseteq\{0,1\}^n\) if \(|T|>0\), then 

$$\Pr[|\{x:x\in T \text{ and }C(x) = 1\}|=1] \geq \frac{1}{8n}$$ 

This lemma seeks to show that the generalized Valiant-Vazirani theorem implies that for every oracle \(A\), that \(\text{NP}^A \subseteq \text{BPP}^{(\bigoplus P^A)}\).

Let \(ğ¿\) be an arbitrary language in \(\text{NP}^A\) that is decided by a nondeterministic oracle turing machine \(M\) that runs in polynomial time. Then, given an input \(x\) we can decide whether it is in \(L\) by using a probabilistic turing machine oracle equipped with the polynomial-time nondeterministic Turing Machine oracle \(\oplus P^A\). Let \(P\) be the list of all the computation paths of \(M\) upon input \(x\) such that for all\(ğ‘ âˆˆ ğ‘‡, p\) ends in an accept state and let the count of the number of accepting computation paths be \(m\). Using lemma 5.1, produce separate circuits \(ğ¶_ğ‘–\) for each computation path \(ğ‘_ğ‘– âˆˆ ğ‘ƒ\), such that \(ğ¶_ğ‘–(ğ‘_ğ‘–) = 1\). Then, a nondeterministic turing machine oracle \(ğ‘€_ğ‘–\) would guess \(x\) such that \(\{ğ‘¥: ğ‘¥ \in ğ‘‡ \text{ and } C_i(x) = 1\}_{ğ‘–=1,...,ğ‘˜}\). Then, \(ğ‘€_ğ‘–\) would verify that the guess belongs in the set by using an oracle \(A\) in polynomial time and returns ACCEPT if the verification is successful. Therefore, \(ğ‘€_i^ğ´ âˆˆ \oplus \text{P}^ğ´\).

Therefore, using \(ğ‘€_i^ğ´\) as an oracle, simulate the \(\text{BPP}\) behavior on a probabilistic turing machine by calling
\(\text{M}_i^ğ´, âˆ€ğ‘–, 1 â‰¤ ğ‘– â‰¤ ğ‘˜\) and counting the number of ACCEPTS returned from the oracle:

If the number of ACCEPTS is odd, then the probabilistic TM returns ACCEPT.

If number of ACCEPTS is even, then the probabilistic TM returns REJECT.


To show that this procedure maps â€œyesâ€ to â€œyesâ€:

Note that if \(ğ‘¥ âˆˆ ğ¿ âˆˆ \text{NP}^ğ´\), then:
    $$ğ‘ƒ(|\{ğ‘¥:ğ‘¥âˆˆğ‘‡ \text{ and }C_i(x)=1\}_ğ‘–|=1) â‰¥ \frac{1}{8ğ‘š}$$
  
Therefore, for \(k\) circuits, the probability of all of them deciding incorrectly becomes:

        $$\leq \bigg(1-\frac{1}{8m}\bigg)^k \approx 1 - \frac{k}{8m} \quad \text{(by taylor expansion)}$$


For this to be in \(\text{BPP}\), the probability of incorrectly deciding a string in \(L\) should be atmost \(\frac{1}{3}\).
  
Therefore, we can choose the number of circuits, \(k\), that the \(\text{BPP}\) would have to make to satisfy this property.

$$1âˆ’\frac{ğ‘˜}{8m} â‰¤ \frac{1}{3} \Rightarrow \frac{2}{3} \leq \frac{k}{8m} \Rightarrow k â‰¥ \frac{16}{3} m$$

If \(ğ‘˜ â‰¥ \frac{16}{3} ğ‘š\), the probability of incorrectly deciding it is atmost \(\frac{1}{3}\). So, the probability of correctly deciding it is atleast \(\frac{2}{3}\).
Therefore, â€œyesâ€ maps to â€œyesâ€.


To show that this procedure maps â€œnoâ€ to â€œnoâ€:

  If \(ğ‘¥ âˆ‰ ğ¿\), then the number of accepting configurations in \(\oplus \text{P}^A\) will be \(0\) which is even.
  Therefore, the probabilistic turing machine will return a REJECT.
  So, â€œnoâ€ maps to â€œnoâ€.

Therefore, we now have that for all \(A\):
$$\text{NP}^A âŠ† \text{BPP}^{(â¨ \text{P}^ğ´)}$$

 QED.







## ** Lemma 2: For any oracle A, \(\text{NP}^A \subseteq \text{BPP}^A \Rightarrow \text{NP}^{\text{NP}^{\text{NP}^{(...^{\text{NP}^A})}}} \subseteq \text{BPP}^A\)** 
** <u>Sub-Lemma 2.1: \(\text{NP}^{\text{BPP}} \subseteq \text{BPP}^{\text{NP}}\)</u>** ial-time nondeterministic turing machine \(M\) and queries oracle \(\text{A} âˆˆ \text{BP}\), we can decide a string of the language using a \(\text{BPP}\) probabilistic turing machine \(Mâ€™\) that queries oracle \(\text{B} âˆˆ \text{NP}\).

Given an input \(x\), there are \(2^{|ğ‘¥|^{ğ‘‚(1)}} = 2^{|ğ‘¥|^ğ‘˜}\) possible computation paths that are generated by \(M\).
Therefore, let the \(\text{BPP}\) machine \(Mâ€™\) query its \(\text{NP}\) turing machine oracle \(2^{|ğ‘¥|^ğ‘˜}\) times (one time for each computation path). On each query let \(Mâ€™\) build up an array of size \(|x|\) of â€œtrueâ€ or â€œfalseâ€ for each path such that if the oracle returns â€œtrueâ€ for every bit, then \(M\) returns â€œtrueâ€.

Then, through repeated error reduction, we can reduce the error of the \(\text{BPP}\) machine to atmost \(\frac{1}{3|x|^k} \times \frac{1}{2^{|x|^k}}\)

Therefore, upon the \(2^{|ğ‘¥|^ğ‘˜}\) computational paths that a nondeterministic turing machine would take, where the number of queries to the oracle are atmost \(|ğ‘¥|^ğ‘˜\), we have that the probability of incorrectly deciding the string becomes:
$$â‰¤ \frac{1}{3|x|^k \times 2^{|x|^k}} \times (2^{|ğ‘¥|^ğ‘˜} \times |ğ‘¥|^ğ‘˜) = \frac{1}{3}$$

It follows then that the probability of correctly deciding the string is atleast \(\frac{2}{3}\). Since this is simulated on a \(\text{BPP}\) machine with a turing machine oracle in \(\text{NP}\), we have that

$$\text{L} âˆˆ \text{BPP}^{\text{NP}}$$

Therefore, we conclude that:

$$\text{NP}^{\text{BPP}} âŠ† \text{BPP}^{\text{NP}}$$

QED.


** <u>Sub-Lemma 2.2: \(\text{BPP}^{\text{BPP}} \subseteq \text{BPP}\)</u>** listic turing machine \(M\) and queries oracle \(ğ´ âˆˆ \text{BPP}\), we can decide a stringof the language by using a \(\text{BPP}\) probabilistic turing machine \(M'\), and we can use error reduction to show that \(ğ¿ âˆˆ \text{BPP}\) by simulating the oracle, where the probability of errors for \(M'\) is \(ğ‘’_2\) and the probability of errors for \(M\) is \(ğ‘’_1\).

Given an input \(x\), query the oracle atleast once on each bit of \(x\). Therefore, the total number of queries would be \(|ğ‘¥|^ğ‘˜\). Hence, the probability of getting an error on a single query is \(ğ‘’_1\) whereas the probability
of getting an error in the entire simulation would be \(|ğ‘¥|^ğ‘˜ ğ‘’_1\). Then, adding in the probability of getting an error in \(M\), we have that the probability of error is: \(|ğ‘¥|^ğ‘˜ ğ‘’_1 + ğ‘’_2\).

Through repeated error reduction, we can reduce the values of \(ğ‘’_1\) and \(ğ‘’_2\) from \(\frac{1}{3}\). However, to show that \(ğ‘¥ âˆˆ \text{BPP}\), we would need:

$$|ğ‘¥|^ğ‘˜ ğ‘’_1 + ğ‘’_2 â‰¤ \frac{1}{3}$$

Note that this is satisfied if we do repeated error reduction as many times as needed until:

$$ğ‘’_1= \frac{1}{6|x|^k},\quad \quad ğ‘’_2=\frac{1}{6},$$

since

$$|ğ‘¥|^ğ‘˜ ğ‘’_1 + ğ‘’_2 = \frac{1}{6} + \frac{1}{6} = \frac{1}{3}.$$

If the probability of an error is \(\frac{1}{3}\), then the probability of success will be \(\frac{2}{3}\). Therefore, through simulating the \(\text{BPP}\) oracle on a \(\text{BPP}\) machine \(M\), we have that:

$$\text{BPP}^{\text{BPP}} \subseteq \text{BPP}$$

QED.

Given lemma 1, \((\text{NP}^{\text{BPP}} âŠ† \text{BPP}^{\text{NP}})\) and lemma 2 \((\text{BPP}^{\text{BPP}} âŠ† \text{BPP})\), we can finally use induction to show that:

$$\text{NP}^ğ´ âŠ† \text{BPP}^ğ´ â‡’ \text{NP}^{(\text{NP}^{(\text{NP}^{(...^{(\text{NP}^ğ´)}... )))}}} âŠ† \text{BPP}^ğ´,$$

where we induct on the height, \(i\), of the \(NP\) tower.


<u>Base Case</u>: \(i = 1\):
When \(i = 1\), the formulation becomes \(\text{NP}^ğ´ âŠ† \text{BPP}^ğ´\), which is known to be true.

<u>Assumptive Case</u>: \(i = k\)
Assume that for height \(k\), 
$$\text{NP}^{(\text{NP}^{(...^{(\text{NP}^ğ´)))}}} âŠ† \text{BPP}^A$$

<u>Inductive Case</u>: \(i = k + 1\)
Expanding to the next level, we get:

$$\text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ğ´)))}}} âŠ† \text{NP}^{\text{BPP}^ğ´}$$

Applying lemma 1 \((\text{NP}^{\text{BPP}} âŠ† \text{BPP}^{\text{NP}})\) to the RHS yields:

$$\text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ğ´)))}}} âŠ† \text{BPP}^{\text{NP}^A}$$

We know that \(\text{NP}^ğ´ âŠ† \text{BPP}^ğ´\). Therefore, the expression becomes:

$$\text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ğ´)))}}} \subseteq \text{BPP}^{\text{BPP}^A}$$

Applying lemma 2 \((\text{BPP}^{\text{BPP}} âŠ† \text{BPP})\) to the RHS yields:

$$\text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ğ´)))}}} \subseteq \text{BPP}^A$$

Therefore, the inductive stage holds for \(i = k + 1\).


<u>Conclusive Step:</u>

 The theorem holds for an \(\text{NP}\) tower of height \(k + 1\) provided that it holds for an \(\text{NP}\) tower of height \(k\).
However, from our basis step, we showed that the theorem holds for an \(\text{NP}\) tower of height \(1\).
Therefore, from the inductive hypothesis, the theorem therefore holds true for any \(\text{NP}\) tower of height \(ğ‘› âˆˆ \mathbb{N}\). 

Hence, we have that:

$$\text{NP}^ğ´ âŠ† \text{BPP}^ğ´ \Rightarrow \text{NP}^{\text{NP}^{(\text{NP}(...^{(\text{NP}^ğ´)))}}} âŠ† \text{BPP}^ğ´$$

QED.





## ** Lemma 3: \(\text{co}\)-\((\oplus P) \subseteq \oplus P\)** 
   

Given an arbitrary language \(ğ¿ âˆˆ \text{co}\)-\((\oplus \text{P})\) that is decided by a nondeterministic polynomial-time turing machine \(M(x, y)\) s.t. \(ğ‘¥ âˆˆ ğ¿\) implies that an even number of computation paths (\(y\) is even) end up on an ACCEPT state and \(ğ‘¥ âˆ‰ ğ¿\) implies that an odd number of computation paths (\(y\) is odd) end up on a REJECT state, we can also decide \(L\) on a \(\oplus \text{P}\) machine \(M'\).

Therefore, we use the following procedure:

\(Mâ€™(x)\):
If \(ğ¿ = \{ğ‘¥ | \text{ number of }y's \text{ s. t. }ğ‘€(ğ‘¥, ğ‘¦) = 1 \text{ is even}\}\), then construct \((\oplus \text{P})\) machine \(M'\) that runs on \(ğ‘€'(ğ‘¥, ğ‘¦)\).

Then, we allow \(Mâ€™(ğ‘¥, ty)\) to have an additional computational path than \(M\) by letting it do the following:

The additional computational path simulates \(M\). If \(M\) accepts, then return ACCEPT. Else, REJECT.

The remaining computational paths decides \(x\) nondeterministically.
It does this by choosing a â€œyesâ€ or â€œnoâ€ branch at every step of the decision tree.
In this case, it would only return ACCEPT if all paths reached the â€œnoâ€ leaf. Otherwise, it would REJECT.


We see here that \(M'\) has exactly 1 more accepting computation path than \(M\). Since \(M\) had an even number of paths, we have that \(Mâ€™\) has an odd number of paths. Therefore, \(ğ¿ = \{ ğ‘¥ | \text{ number of y's s.t. } ğ‘€'(ğ‘¥, ğ‘¦) =
1 \text{ is odd}\}\). Hence, \(ğ¿ âˆˆ \oplus \text{P}\).

Since \(ğ¿ âˆˆ \oplus \text{P}, ğ¿ âˆˆ \text{co}\)-\(\oplus \text{P}\), we use the transitivity property to conclude that:

$$\text{co -}\oplus \text{P} âŠ† \oplus \text{P}$$

QED.



## ** Lemma 4: \((\oplus \text{P})^{\oplus \text{P}} \subseteq \oplus \text{P}\)** 
Given an arbitrary language \(ğ¿ âˆˆ (\oplus \text{P})^{\oplus \text{P}}\) that is decided by a nondeterministic turing machine \(M\) which queries an oracle \(ğ´ âˆˆ \oplus\text{P}\), we can show that it is also decided by a nondeterministic turing machine \(M'\) s.t. \(ğ¿ = \{x: |\{y: M'(x,y)=1\}| \text{ is odd}\}\).


First use the method suggested in the hint, knowing that there exists some nondeterministic guess that produces a correct transcript that concurs with \(M\) on the specified computation path.

Then, we use the following strategy to decide on an input \(x\).

\(Mâ€™(x)\):
Guess a transcript of \(M\) on \(x\). If the transcript is not accurate, then REJECT immediately.
If the transcript is not an accepting configuration, then return REJECT.

For all accurate queries (as determined by the transcript):

Nondeterministically guess the computation path of a TM \(B\) for \(A\) on each query it is sent. 

If each of these computation paths leads to an accept state in \(B\), then return ACCEPT.

For all inaccurate queries (as determined by the transcript):

Nondeterministically guess the computation path of a TM \(B'\) for \(\bar{A}\)) on each query it is sent.

If each of these computation paths leads to an accept state in \(B'\), then also return ACCEPT.

Therefore, we claim that this nondeterministic polynomial-time turing machine \(M'\) described above can decide \(x\). To prove this, we show that â€œyesâ€ maps to â€œyesâ€ and â€œnoâ€ maps to â€œnoâ€.

To show that â€œyesâ€ maps to â€œyesâ€:

The transcript that was guessed would let \(M'\) guess \(\chi\) accepting computation paths.
\(\chi\) is the total number of paths that can be taken.

There are an odd number of computation paths for queries that the transcript says are accurate.
 There are an odd number of computation paths for queries that the transcript says are not accurate. So:

$$ğœ’ = (2k + 1)(2\ell + 1) = 4k\ell + 2\ell + 2k + 1 = 2(2k\ell + \ell + k) + 1 âˆˆ \text{ odd }$$

Therefore, we have that â€œyesâ€ instances of \(L\) will get mapped to â€œyesâ€ by \(M'\).

To show that â€œnoâ€ maps to â€œnoâ€:
If the instance is â€œnoâ€, then:

1) The transcript guessed would not be accurate
2) The transcript guessed would not be an accepting configuration.
3) The number of computation paths for accurate queries / inaccurate queries are even.
3)The number of accepting configurations are not even either

The procedure outlined above, however, ensures that \(M'\) REJECTs on all of these possibilities.

Since we have shown that â€œyesâ€ maps to â€œyesâ€ and â€œnoâ€ maps to â€œnoâ€, we conclude the proof of correctness for this procedure, and therefore we have that:

$$L \in \oplus \text{P}$$

Then, by the property of transitivity, we have that:

$$(\oplus \text{P})^{\oplus \text{P}} \subseteq \oplus \text{P}$$

QED.





## ** Lemma 5: \(\text{PH} \subseteq \text{BPP}^{\oplus \text{P}}\)** 
Let \(L\) be an arbitrary language such that \(ğ¿ âˆˆ \text{PH}\), where

$$ \text{PH} = \bigcup\limits_{k \in \mathbb{N}} \Sigma_k^P$$

It follows then that we need to show that \(âˆ€ğ‘˜, Î£_k^ğ‘ƒ âŠ† BPP^{\bigoplus \text{P}}\). Therefore,

$$\text{NP}^A âŠ† \text{BPP}^{(\oplus \text{P}^A)} \quad \text{(from Lemma 1)}$$

Let \(A âˆˆ \oplus \text{P}\). It follows then that since \((\oplus \text{P})^{\oplus \text{P}} âŠ† \oplus \text{P}\) (proven in Lemma 2), we can simply replace \(\oplus \text{P}^A\)
with some language \(A' âˆˆ \oplus \text{P}\). Therefore, we have that:

$$\text{NP}^A âŠ† \text{BPP}^{A'}$$

Then, let \(B âˆˆ \oplus \text{P}\)-complete. It follows then that since \(B\) can be reduced to \(ğ´\), \(A'\) , we can rewrite the above set inclusion as:

$$\text{NP}^B âŠ† \text{BPP}^B$$

Given the above set-inclusion to be true, we also know that:

$$\text{NP}^{\text{NP}^B} \subseteq \text{BPP}^B$$
$$\text{NP}^{\text{NP}^{\text{NP}^B}} \subseteq \text{BPP}^B$$
$$\text{NP}^{\text{NP}^{\text{NP}^{\text{NP}^{\text{NP}^{...^{\text{NP}^B}}}}}} \subseteq \text{BPP}^B$$


Therefore, we have that for all \(k\) levels in the \(\text{NP}\)-tower:

$$\{\text{NP}^{\text{NP}^{...^{\text{NP}^ğµ}}}\} âŠ† \text{BPP}^B$$


However, by definition the LHS (with a height of \(k\)) is equal to \(Î£_k^P\). Therefore, we now have that for all \(k\), we can just construct the \(\text{NP}\)-tower of height \(k\) and it would still be contained in \(\text{BPP}^ğµ\).

$$âˆ€ğ‘˜, Î£_k^ğ‘ƒ âˆˆ \text{BPP}^ğµ$$

$$ \text{PH} = \bigcup\limits_{k \in \mathbb{N}} \Sigma_k^P \in \text{BPP}^B$$

$$\text{PH} \subseteq \text{BPP}^B, \quad B \in \oplus \text{P-complete}$$

This then yields:
$$\text{PH} âŠ† \text{BPP}^{\oplus \text{P}}$$

QED.





## ** Lemma 6: The efficient constrution of a circuit \(C'\) with satisfying assignments of cardinality \(g(|C|)\), where g is a fixed non-negative polynomial and C is a fixed circuit.** t">
Our aim over the next 3 lemmas is to show that the ability to count is sufficient to capture the entire computational power of the polynomial hierarchy.

So, let \(C\) be Boolean circuit, and let \(g\) be a polynomial with nonnegative integer coefficients. The broad goal of this lemma is to describe a deterministic procedure that, given \(C\), produces a circuit \(C'\) such that

$$|\{ğ’š: ğ‘ª'(ğ’š) = ğŸ\}| = ğ’ˆ(|\{ğ’™: ğ‘ª(ğ’™) = ğŸ\}|)$$

Additionally, this construction should run in polynomial-time in the size of \(C\) and use space atmost in the size of \(g\), when it is encoded in the natural way as a vector of coefficients.

<u>Sub-Lemma 6.1</u>: Given two circuits \(A\) and \(B\) with \(\alpha\) and \(\beta\) satisfying assignments respectively, we can produce a circuit \(C\) with \(\alpha + \beta\) satisfying assignments:

We first start by examining the result when \(C = A \vee B\).


<style>
.table_center {
  margin-left: auto;
  margin-right: auto;
  width:30%;
}
</style>

<table class="table_center">
  <tr>
    <th>\(A\)</th>
    <th>\(B\)</th>
    <th>\(C\)</th>
  </tr>
  <tr>
    <th>\(0\)</th>
    <th>\(0\)</th>
    <th>\(0\)</th>
  </tr>
  <tr>
    <th>\(0\)</th>
    <th>\(1\)</th>
    <th>\(1\)</th>
  </tr>
  <tr>
    <th>\(1\)</th>
    <th>\(0\)</th>
    <th>\(1\)</th>
  </tr>
  <tr>
    <th>\(1\)</th>
    <th>\(1\)</th>
    <th>\(1\)</th>
  </tr>
</table>

However, noting that A and B might have inputs of differing dimensions:
The total number of satisfying assignments when A and B are combined simply using the OR operator is:

$$\#ğ‘†ğ´ğ‘‡(ğ¶) = ğ›¼ğ›½ + ğ›¼(2^{dim(ğ´)} âˆ’ğ›½) + ğ›½(2^{dim(ğµ)} âˆ’ğ›¼) â‰  ğ›¼ + ğ›½$$

On the other hand, when \(ğ¶ = ğ´ â¨ ğµ\), where \(dim(ğ´) = dim(ğµ) = 1\):

<table class="table_center">
  <tr>
    <th>\(A\)</th>
    <th>\(B\)</th>
    <th>\(C\)</th>
  </tr>
  <tr>
    <th>\(0\)</th>
    <th>\(0\)</th>
    <th>\(0\)</th>
  </tr>
  <tr>
    <th>\(0\)</th>
    <th>\(1\)</th>
    <th>\(1\)</th>
  </tr>
  <tr>
    <th>\(1\)</th>
    <th>\(0\)</th>
    <th>\(1\)</th>
  </tr>
  <tr>
    <th>\(1\)</th>
    <th>\(1\)</th>
    <th>\(0\)</th>
  </tr>
</table>

$$\#ğ‘†ğ´ğ‘‡(ğ¶) = ğ›¼ + ğ›½$$

Therefore, we then try the following approach (letting \(dim(ğ´) = ğ‘‘_ğ´\), \(dim(ğµ) = ğ‘‘_ğµ\)):

<table class="table_center">
  <tr>
    <th>\(d_A\)</th>
    <th>If the first \(ğ‘‘_ğ´\) bits are true and the last \(ğ‘‘_ğµ\) bits satisfy \(B\), then return true.</th>
  </tr>
  <tr>
    <th>\(d_B\)</th>
    <th>If the first \(ğ‘‘_ğ´\) bits satisfy \(A\) and the last \(ğ‘‘_ğµ\) bits are true, then return true.</th>
  </tr>
</table>

The resultant circuit produces \(Î± + ğ›½\) satisfying instances in all cases except when \(ğ´\) and \(B\) are both satisfying instances (here the resultant circuit produces \(Î± + Î² âˆ’ 1\) satisfying instances).

Therefore, in this case we can then attempt a workaround by introducing a dummy variable \(ğœ“\) that negates both the instances when \(ğ´ = ğµ = \text{ True}\).

Therefore, we let:

$$ğ¶ = (Â¬ğœ“ âˆ§ \tilde{A}) âˆ¨ (ğœ“ âˆ§ \tilde{ğµ}),$$

where \(\tilde{ğ´}\) is the circuit that checks satisfiability of the first \(d_A\) assignments to the \(ğ´\) circuit and checks that the remaining bits are all TRUE (by ANDing them), and where \(\tilde{ğµ}\) is the circuit that
checks that the first \(d_A\) assignments are all TRUE (by ANDing them), and that the remaining \(d_B\) bits are satisfying assignments to the \(ğµ\) circuit.

Therefore, the negated Boolean variable \(ğœ“\) in one of the clauses is then able to add the additional count for when \(A\) and \(B\) are true.

QED.


<u>Sub-Lemma 6.2</u>: Given two circuits \(A\) and \(B\) with \(ğ›¼\) and \(ğ›½\) satisfying assignments respectively, we can produce a circuit \(C\) with \(\alpha\beta\) satisfying assignments:

We claim that \(C = A \wedge B\). To prove that \(C\) yields \(ğ›¼ğ›½\) satisfying assignments, let \(\tilde{ğ´}\) be the set of satisfying assignments of \(A\), and let \(\tilde{B}\) be the set of satisfying assignments of \(B\). Therefore, the cardinality of the set of tuples \(\tilde{ğ´} Ã— \tilde{ğµ} = |\tilde{A}| Ã— |\tilde{B}|\).

The onus is then to prove that:

1) \(âˆ€ğ‘¥ âˆˆ \tilde{ğ´} Ã— \tilde{ğµ}, ğ‘¥\) is a satisfying assignment of \(C\):

If \(âˆ€ğ‘¥ âˆˆ \tilde{A} Ã— \tilde{ğµ}\), then \(ğ‘¥\) consists of a (satisfying, satisfying) assignment, one from \(\tilde{ğ´}\) and another from \(\tilde{ğµ}\).
Therefore, \(ğ‘¥\) will clearly satisfy an AND gate which takes as input any possible value of \(x\).
Hence, \(x\) is a satisfying assignment of \(C\).

2) \(âˆ€ğ‘¥ \text{ s.t. } ğ¶(ğ‘¥)=1, ğ‘¥âˆˆ\tilde{ğ´} Ã— \tilde{ğµ}\):

If \(ğ¶(ğ‘¥) = 1\), then \(ğ‘¥ âˆˆ\) (satisfying, satisfying) which implies that it must be in \(\tilde{A}\times\tilde{B}\).
This is because\(\tilde{ğ´}\) and \(\tilde{ğµ}\) contain all the satisfying assignments for \(A\) and \(B\) respectively.
Therefore, \(ğ‘¥ âˆˆ \tilde{ğ´} Ã— \tilde{ğµ}\).

Therefore, \(ğ¶ = ğ´ âˆ§ ğµ\) will have \(ğ›¼ğ›½\) satisfying assignments where \(A\) has \(ğ›¼\) satisfying assignments and \(B\) has \(ğ›½\) satisfying assignments.

QED.



<u>Sub-Lemma 6.3</u>: We can construct a circuit C with ğ‘¡ satisfying assignments:
We create a circuit \(ğ‘‡\) that has \(ğ‘¡_i\) satisfying assignments by noting that we can just return TRUE if the bit-value \(< t_i\). The minimum number of bits necessary here would be equivalent to the minimum number of bits necessary to represent \(ğ‘¡_ğ‘–\) which would be \(log(ğ‘¡_ğ‘–)\).


Therefore, to now prove the main lemma, given a circuit \(C\) with \(ğ‘\) satisfying assignments and a positive-coefficient polynomial \(ğ‘”:\mathbb{N} \rightarrow\mathbb{N}\), we can construct a deterministic procedure that simply produces a circuit \(C'\) with \(ğ‘”(ğ‘)\) satisfying assignments. The polynomial \(g\) is:

$$ g(x) = \sum\limits_{i=0} t_i x^i$$ 

To evaluate the circuit and the lemmas on this polynomial (the wording here is intentional), we need to start by finding \(ğ‘¥_ğ‘–\), then using that to find \(t_i x^i\) and then adding that \(âˆ€i's\):

For each \(i\), we can create a circuit \(ğ¶_{ğ‘–_1}\) with \(ğ‘^i\) assignments by ANDâ€™ing the existing circuit to \(C\) \(i\) times (using lemma 6.2).

We then create a circuit \(ğ‘‡\) that has \(ğ‘¡\) satisfying assignments by using lemma 6.3. 

Then, by lemma 6.2, we have that the \(i\)â€™th term in the polynomial would be represented by a circuit \(ğ¶_{i_2} = ğ¶_{i_1} \text{ AND } ğ‘‡_i\).

Finally, we perform lemma 6.1 on \(C_{i_2}, \forall i\) to produce \(ğ¶'\) with \(Î£_{i=0}^{deg(ğ‘”)}[\#\text{SAT}(ğ¶_{ğ‘–_2})] = ğ‘”(ğ‘)\) satisfying assignments.

Then, return \(ğ¶'\).


Finally, the onus of the proof is to show that the run-time of the procedure is in the size of \(C\) and \(g\):

Everytime lemmas 6.1, 6.2, and 6.3 are applied, an \(ğ‘‚(|ğ¶|)\), \(ğ‘‚(1)\) and \(ğ‘‚(\log t_i)\) number of gates are added (each of which can be added in \(ğ‘‚(1)\) time) respectively. Therefore, the total number of gates that would need to be added throughout the entire procedure would be atmost:

$$ğ‘‡(ğ‘”, ğ¶) â‰¤ ğ‘‚(|ğ¶|)(\text{deg}(ğ‘”) + ğ‘‚(1)) \text{deg}(ğ‘”) + \max\limits_i ğ‘‚(\log t_i)$$

$$ğ‘‡(ğ‘”, ğ¶) â‰¤ ğ‘‚(|ğ¶|)\text{deg}(ğ‘”) + ğ‘‚(|ğ¶|) + \max\limits_i ğ‘‚(\log t_i) = \text{poly}(|C|, g) ğ‘–$$

Therefore, the runtime of this procedure is in the size of \(C\), and takes space atmost \(g\). Hence, we now have a procedure that produces a circuit \(C'\) given \(C\) such that:

$$|{ğ‘¦: ğ¶'(ğ‘¦) = 1}| = ğ‘”(|{ğ‘¥: ğ¶(ğ‘¥) = 1}|)$$

QED.






## ** Lemma 7: Constructing an efficiently computable non-negative polynomial \(g(t)\) for which \(t\equiv k\mod 2 \Rightarrow g(t) \equiv k \mod 2^m\), where \(m\) is a power of 2.** ass="content"


The purpose of this lemma is to create a deterministic procedure that, given \(m\) a power of two, outputs (as a sequence of coefficients) a polynomial \(ğ’ˆ: \mathbb{Z} â†’ \mathbb{Z}\) with nonnegative integer coefficients for which
$$t \equiv 0 \mod 2 \Rightarrow g(t) \equiv 0 \mod 2^m$$
$$t \equiv 1 \mod 2 \Rightarrow g(t) \equiv 1 \mod 2^m$$
and that runs in time \(poly(m)\).

<u>Sub-Lemma 7.1</u>: \(t\equiv 0\mod 2^{2^i} \Rightarrow g_0(t) \equiv 0 \mod 2^{2^{i+1}}\), where \(g_0(t)=3t^2 - 2t^3\):

Given that \(ğ‘”_0(t) = 3t^2 âˆ’ 2t^3 = t^2(3 âˆ’ 2t)\) and that \(t \equiv 0 \mod 2^{2^i}\), we let \(t = k\cdot 2^{2^i}, k \in \mathbb{N}\). It follows then that:
$$g_0(t) = t^2(3 âˆ’ 2t) = ğ‘˜^2 (2^{2^i})^2 (3âˆ’2(ğ‘˜\cdot 2^{2^ğ‘–}))$$
$$= 3k^2 \cdot 2^{2^{ğ‘–+1}} âˆ’ 2k^3 \cdot 2^{2Ã—2^{i+1}}$$
$$=3k^2 \cdot 2^{2^{ğ‘–+1}} âˆ’8k^3 \cdot 2^{2^{i+1}}$$
$$= (\alpha + \beta) \cdot 2^{2^{i+!}}$$
$$= \gamma \cdot 2^{2^{i+1}}$$

Then, since \(ğ›¼ âˆˆ \mathbb{N}, ğ›½ âˆˆ \mathbb{N}\), it follows that \(\gamma âˆˆ \mathbb{N}\). Therefore,
$$\gamma \cdot 2^{2^{i+1}} \equiv 0 \mod 2^{2^{i+1}}$$
QED.




<u>Sub-Lemma 7.2</u>: \(t\equiv 1 \mod 2^{2^i} \Rightarrow g_0(t) \equiv 1 \mod 2^{2^{i+1}}\), where \(g_0(t) = 3t^2 - 2t^3\):

Given that \(g_0(t) = 3t^2 âˆ’ 2t^3 = t^2(3 âˆ’ 2t)\) and that \(t \equiv 1 \mod 2^{2^i}\), we let \(t=k\cdot 2^{2^i}+1\), for \(k \in \mathbb{N}\). It follows then that

$$g_0(t) = t^2(3 âˆ’ 2t)$$

$$=(1+k^2\cdot 2^{2^{ğ‘–+1}} + k\cdot 2^{2^{i+1}})(3 - 2 - k\cdot 2^{1+2^i})$$

$$ = 1 + 2^{2^{1+i}}k^2 âˆ’ 2^{2+2^{1+i}}k^2 âˆ’ 2^{1+2^i+2^{1+i}}k^3$$

$$= 1 + 2^{2^{1+i}}(âˆ’3ğ‘˜^2) âˆ’ (1 + 2^i)k^3 2^{2^{1+i}}$$

$$= 1 + 2^{1+2^i}(-(2^i+1)k^3 - 3k^2)$$

Then, since \(ğ‘˜, ğ‘– âˆˆ \mathbb{N}\), it follows that:

$$g_0(t)=1+2^{1+2^ğ‘–}ğ›½,\quad ğ›½âˆˆ\mathbb{N}$$

Hence,
$$ğ‘”_0(t)=1+\beta\cdot 2^{2^{i+1}} \equiv 1 \mod 2^{2^{i+1}}$$

QED.


Our goal is now to construct a deterministic procedure that outputs the coefficients of a polynomial \(ğ‘”: \mathbb{Z} â†’ \mathbb{Z}\) with nonnegative integer coefficients for which:

$$ğ‘¡ \equiv 0 \mod 2 \Rightarrow ğ‘”(ğ‘¡) \equiv 0 \mod 2^ğ‘š$$

$$ğ‘¡ \equiv 1 \mod 2 \Rightarrow ğ‘”(ğ‘¡) \equiv 1 \mod 2^ğ‘š$$

and that runs in \(ğ‘ğ‘œğ‘™ğ‘¦(ğ‘š)\) where \(m\) is a power of \(2\). Therefore, let \(ğ‘š = 2^ğ‘˜\), for \(ğ‘˜ âˆˆ \mathbb{N}\). It follows then that we want to construct a procedure that outputs the coefficients to a polynomial \(g: \mathbb{Z} \rightarrow \mathbb{Z}\) such that

$$ğ‘¡ \equiv 0 \mod 2 \Rightarrow ğ‘”(ğ‘¡) â‰¡ 0 \mod 2^{2^ğ‘˜}$$

$$t â‰¡ 1 \mod 2 \Rightarrow ğ‘”(ğ‘¡) â‰¡ 1 \mod 2^{2^k}$$

To do so, we recall lemmas 7.1 and 7.2 with \(ğ‘”_0(t) = 3t^2 âˆ’ 2t^3\) in that every application of \(ğ‘”_0\) causes the exponent of the exponent of the mod to increment by 1. Therefore, we claim that the coefficients of \(ğ‘”_0 âˆ˜ ğ‘”_0 âˆ˜ ... âˆ˜ ğ‘”_0(ğ‘¡) = ğ‘”(ğ‘¡)\) where \(k\) compositions are done.

To prove this, we use mathematical induction on \(k\):

<u>Base Case</u>: \(ğ‘˜ = 1, ğ‘š = 0\)

No compositions would be done, so we would require \(ğ‘”(ğ‘¡) = ğ‘¡\). However, when

$$ğ‘¡\equiv 0 \mod 2, g(t) \equiv 0 \mod 2^{2^0} \equiv 0\mod 2 = t$$

$$ğ‘¡\equiv 1 \mod 2, g(t) \equiv 1 \mod 2^{2^0} \equiv 1\mod 2 = t$$

Hence the base case is satisfied.

<u>Assumptive case</u>: We assume that \(g(ğ‘¡) = ğ‘”_0 âˆ˜ ... âˆ˜ ğ‘”_0 (ğ‘¡)\) for \(ğ‘˜ â‰¤ ğ‘›\) compositions is true.

<u>Inductive case</u>: When \(ğ‘˜ = ğ‘› + 1\), we have that from the \((ğ‘˜ âˆ’ 1)\)th composition (by the assumptive step), we would have:

$$t\equiv 0 \mod 2 \Rightarrow ğ‘”'(t) \equiv 0 \mod 2^{2^{k-1}}$$

$$t\equiv 1 \mod 2 \Rightarrow ğ‘”'(t) \equiv 1 \mod 2^{2^{k-1}}$$

Therefore, when we perform the \(k\)â€™th composition, we would then get:

$$ğ‘¡\equiv 0 \mod 2 \Rightarrow ğ‘”(ğ‘¡) \equiv 0\mod 2^{2^k}$$

$$ğ‘¡\equiv 1 \mod 2 \Rightarrow ğ‘”(ğ‘¡) \equiv 1\mod 2^{2^k}$$

Therefore, by the inductive hypothesis from the base case, we now have that \(ğ‘”_0 âˆ˜ ğ‘”_0 âˆ˜ ... âˆ˜ ğ‘”_0 (ğ‘¡) = ğ‘”(ğ‘¡)\) where \(k\) compositions are done. As desired.


Finally, the onus of this proof is to show that this procedure runs in polynomial time in \(m\):

To do this, we note that each step of the composition involves atleast \(k\) evaluations through multiplication.

Therefore, the total number of multiplications would across all the steps would be \(O(2^k) = O(m)\). 
Each multiplication runs in \(ğ‘ğ‘œğ‘™ğ‘¦(ğ‘‚(ğ‘˜)) âˆˆ ğ‘ğ‘œğ‘™ğ‘¦(ğ‘š)\) time. 
The total time complexity of this procedure is \(ğ‘ğ‘œğ‘™ğ‘¦(ğ‘š) Ã— ğ‘‚(ğ‘š) = ğ‘ğ‘œğ‘™ğ‘¦(ğ‘š)\).

QED.






## ** Lemma 8: Concluding that \(\text{PH} \subseteq \text{P}^{\# \text{P}}\)** 
Recall Lemmas \(1\) and \(2\) which state that
$$\text{PH} âŠ† \text{BPP}^{\oplus \text{P}} $$
$$(\oplus \text{P})^{\oplus \text{P}} âŠ† \oplus \text{P} $$

<u>Lemma 8.1</u>: any language in \(\text{BPP}^{\oplus \text{P}}\) can be decided in \(BPP^{\oplus \text{P}}\) with the oracle machine making a single query and then immediately entering \(q_\text{accept}\) or \(q_\text{reject}\).

Let \(ğ¿ âˆˆ \text{BPP}^{\oplus \text{P}}\). Let \(M\) be a probabilistic \(TM\) with oracle \(\text{P}^{\oplus \text{P}}\) that decides a string \(x\) through the following procedure (and only tossing the coins redundantly):

\(M(x)\):
Toss the \(c = |ğ‘¥|\) coins and write down the results (what is actually done with the results is not relevant right now).

Query the oracle \(\text{P}^{\oplus \text{P}}\) on \(x\).

If the oracle returns ACCEPT, then enter \(ğ‘_\text{ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡}\). If the oracle returns REJECT, then enter \(ğ‘_\text{ğ‘Ÿğ‘’ğ‘—ğ‘’ğ‘ğ‘¡}\).

Therefore, we have that \(M\) decides \(L\) in \(\text{BPP}^{\text{P}^{\oplus \text{P}}}\). Recall Lemma 2 which states that \((\oplus \text{P})^{\oplus \text{P}} âŠ† \oplus \text{P}\). Since \(\text{P} âˆˆ \oplus \text{P}\), we have that \(\text{P}^{\oplus \text{P}} âŠ† \oplus \text{P}\). Therefore, \(M\) decides \(L\) in \(\text{BPP}^{\oplus \text{P}}\).

QED.



<u>Lemma 8.2</u>: The outcome of the query is determined by the number of satisfying assignments of some circuit \(C\).

For the query made by \(M\) to \(\oplus \text{P}\), we let the turing machine that decides \(\oplus \text{P}\) be denoted as \(M'\). It follows then that \(M'\) has an equivalent circuit \(C\). It follows immediately that the outcome of the query (of form \(q: \{0, 1\}^c \rightarrow \{0, 1\}\) (where \(c\) is the number of coins)) depends on \(C\).

To determine the relationship further, we recall that \(\oplus \text{P}\) returns ACCEPT if the number of computation paths is odd and REJECT if it is even. Therefore, for an oracle query \(q\) to return ACCEPT, the number of satisfying assignments for \(C\) would have to be odd (\(\equiv 1 \mod 2)\), and for it to return REJECT, the number of satisfying assignments for \(C\) would have to be even \((\equiv 0 \mod 2)\).

Hence, we conclude that the outcome of the query is determined by the number of satisfying assignments of some circuit \(C\).

QED.


We now use Lemma \(7\) to produce a polynomial \(ğ‘”: \mathbb{N} â†’ \mathbb{N}\) such that \(ğ‘¡ \equiv 0 \mod 2 \Rightarrow g(t) \equiv 0 \mod 2^m\) and \(ğ‘¡ \equiv 1 \mod 2 \Rightarrow g(t) \equiv 1 \mod 2^m\), where \(m = c\) (the number of coins used by the turing machine \(M\)).

We then use part a (providing circuit \(C\) with \(s\) satisfying assignments as an input) to produce circuit \(C'\) with \(ğ‘”(ğ‘ )\) satisfying assignments). Therefore, \(C'\) would have

$$0 \mod 2^c \text{ satisfying assignments if } ğ¶ \text{ had } 0 \mod 2 \text{ satisfying assignments}.$$

$$1 \mod 2^c \text{ satisfying assignments if } ğ¶ \text{ had } 1 \mod 2 \text{ satisfying assignments}.$$

The onus of the proof is to now show that the language can be decided by a deterministic polynomial-time
turing machine \(Q\) that uses nondeterministic polynomial-time turing machine oracle \(Q'\) that runs in \(\#ğ‘ƒ\).

From lemma \(8.1\), we have that since the language \(L\) is decided by \(\text{BPP}\), atleast \(\frac{2}{3}\) of the computation paths correctly produce circuit \(C'\) when \(ğ‘¥ âˆˆ ğ¿\) such that \(C'\) has \(1 \mod 2^c\) satisfying assignments. Similarly, atmost \(\frac{1}{3}\) of the computation paths correctly produce circuit \(C'\) when \(ğ‘¥ âˆ‰ ğ¿\) such that \(C'\) has \(0 \mod 2^c\) satisfying assignments. Therefore, the total number of paths that produce \(C'\) with \(1 \mod 2^c\) satisfying assignments when \(ğ‘¥ âˆˆ ğ¿\) is \(â‰¥ \frac{2}{3}\cdot 2^c\), whereas the total number of paths that produce \(C'\) with \(0 \mod 2^c\) satisfying assignments when \(ğ‘¥ âˆ‰ ğ¿\) is \(â‰¤ \frac{1}{3} \cdot 2^c\).

Note then that we can use a \(\#ğ‘ƒ\) oracle to find the total length of the set \(ğ‘† = (ğ‘¥ = \{0,1\}^ğ‘) Ã— ğ‘–\) such that
\(ğ¶'(ğ‘(ğ‘¥), i) = 1\) where \(ğ‘¥\) is every possible input of length \(c\) in the set, \(ğ‘(ğ‘¥)\) is a result of querying \(x\), and \(i\) is the \(d\)-dimensional input to \(C'\).

Then, a polynomial procedure \(H\) does the following:

Use the method described in the previous paragraph to query an oracle to find the length of the set, |ğ‘†|.
Calculate \(ğ‘˜ = |ğ‘†| \mod 2^c\).

If \(ğ‘˜ â‰¥ \frac{2}{3} \cdot 2^c\), then return ACCEPT.

If \(ğ‘˜ â‰¤ \frac{2}{3} \cdot 2^c\), then return REJECT.

There are atleast \(\frac{2}{3}\) accepting paths that we explicitly search for and atmost \(\frac{1}{3}\) rejecting paths that we explicitly search for by using \(\#\text{P}\) which is then verified through the modulo operation by procedure \(H\). Hence, we now have that any for an arbitrary language \(ğ¿ âˆˆ \text{BPP}^{\oplus \text{P}}\), \(ğ¿ âˆˆ \text{P}^{\#\text{P}}\). Therefore, we now have that:

$$\text{BPP}^{\oplus \text{P}} âŠ† \text{P}^{\#\text{P}}$$

However, recall result 1 from the previous set that:

$$\text{PH} âŠ† \text{BPP}^{\oplus \text{P}}$$

Therefore, by the property of transitivity we now have that

$$\text{PH} âŠ† \text{P}^{\#\text{P}}$$

QED.
