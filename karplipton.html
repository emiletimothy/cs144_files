# Proving the Karp-Lipton theorem: \(\text{PH} = S_2^P\)

Happy Monday! Today, I'm going to share something really cool about the polynomial hierarchy. I know that I've written prior entries about the polynomial hierarchy where I've praised some of its properties, but this result about the Polynomial Hierarchy is the WILDest thing ever! If you're new here, I'm going to start by giving my regular schpiel about what the polynomial hierarchy is.

Define \(\Delta_0^P := \Sigma_0^P := \Pi_0^P:=P\), where \(P\) is the set of problems that can be solved in poly-time. Then, for all \(i \geq 0\), define:

$$\Delta_{i+1}^P:=\text{P}^{\Sigma_i^P}$$
$$\Sigma_{i+1}^P:=\text{NP}^{\Sigma_i^P}$$
$$\Pi_{i+1}^P:=\text{coNP}^{\Sigma_i^P}$$

The polynomial-time hierarchy is defined as:

$$\text{PH} = \bigcup_{i\in\mathbb{N}} \{\Delta_i^P, \Sigma_i^P, \Pi_i^P\}$$

The result that I want to show here is that every language in the polynomial hierarchy is equivalent in computational power to the complexity class of symmetric functions \(S_2^P\), which resides between the first and second levels of the polynomial hierarchy.

The formal definition of \(S_2^P\) is that any language \(L\) is said to be in \(S_2^P\) if there is a polynomial-time predicate \(P\) such that:
If \(x\in L\), then there exists a \(y\) such that for all \(z\), \(P(x,y,z)=1\)
If \(x\not\in L\), then there exists a \(z\) such that for all \(y\), \(P(x,y,z)=0\)

Another, more intuitive way to look at \(S_2^P\) is the following: Suppose that a polynomial-time computable judge has to decide whether a string \(x\) is in a language \(L\). Two lawyers submit written arguments to convince the judge, one arguing for the string in the language and the other arguing for the string to be out of the language. Neither lawyer can see the others arguments. For what languages can we have the judge always convinced? (The answer is \(S_2^P\)!)


## **Lemma 1: \(S_2^p \subseteq (\Sigma_2^P \cup \prod_2^p) \subseteq \text{ZPP}^\text{NP}\)**
    
Let L be an arbitrary language in \(ğ‘†_ğ‘\). It follows by definition then that:

$$ ğ‘¥ âˆˆ ğ¿ â‡’ âˆƒğ‘¦ âˆ€ğ‘§, (ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…$$

$$ ğ‘¥ âˆ‰ ğ¿ â‡’ âˆƒğ‘§ âˆ€ğ‘¦, (ğ‘¥, ğ‘¦, ğ‘§) âˆ‰ ğ‘… $$

However, note that the order of the universal and existential quantifiers is commutative in this case only if the commutator is taken in both directions. So, from this we can write two alternate versions of the definition, where version 1 commutes the quantifiers in the case for \(ğ‘¥ âˆˆ ğ¿\) while holding the case for \(ğ‘¥ âˆ‰ ğ¿\) to be constant, and version 2 commutes the quantifiers in the case for \(ğ‘¥ âˆ‰ ğ¿\) while holding the case for \(ğ‘¥ âˆˆ ğ¿\) to be constant. This procedure yields:

Version 1:
$$ğ‘¥ âˆˆ ğ¿ â‡’ âˆ€ğ‘§ âˆƒğ‘¦, (ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…$$
$$ğ‘¥ âˆ‰ ğ¿ â‡’ âˆƒğ‘§ âˆ€ğ‘¦, (ğ‘¥, ğ‘¦, ğ‘§) âˆ‰ ğ‘…$$


Version 2:
$$ğ‘¥ âˆˆ ğ¿ â‡’ âˆƒğ‘¦ âˆ€ğ‘§, (ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…$$
$$ğ‘¥ âˆ‰ ğ¿ â‡’ âˆ€ğ‘¦ âˆƒğ‘§, (ğ‘¥, ğ‘¦, ğ‘§) âˆ‰ ğ‘…$$

However, by definition, the complexity class that version 1 decides is equal to \(\Sigma_2^P\), and the complexity class
that version 2 decides is equal to \(\Pi_2^P\). Therefore, if \(ğ‘¥ âˆˆ S_2^P\) then \(ğ‘¥ âˆˆ \Sigma_2^P\) and \(ğ‘¥ âˆˆ \Pi_2^P\).
Therefore, we have that:
$$S_2^ğ‘ƒ âŠ† (\sigma_2^P âˆ© \Pi_2^P)$$

QED.


## **Lemma 2: LEX-FIRST-ACCEPTANCE is \(\text{P}^{\text{NP}}\)-complete.**

The language LEX-FIRST-ACCEPTANCE consists of those pairs \((ğ‘ª_ğŸ, ğ‘ª_ğŸ)\) for which \(ğ‘ª_ğŸ, ğ‘ª_ğŸ\) are circuits, and the lexicographically first-string \(x\) for which \(ğ‘ª_ğŸ(ğ’™) = ğŸ\) is also accepted by \(ğ‘ª_ğŸ\). (If there is no lexicographically first string, i.e., \(ğ‘ª_ğŸ\) is unsatisfiable, then \((ğ‘ª_ğŸ, ğ‘ª_ğŸ)\) is not in the language). A bitstring \(x\) lexicographically precedes a bitstring \(y\) if the first position \(i\) in which they differ has \(ğ’™_ğ’Š = ğŸ\) and \(ğ’š_ğ’Š = ğŸ\).

The purpose of this lemma is to show that LEX-FIRST-ACCEPTANCE is \(P^{\text{NP}}\)-complete - that not only is it solvable by \(P^{\text{NP}}\) Turing Machine, but also it is representative of every problem in the \(P^{\text{NP}}\) complexity class.

<u>Sub-Lemma 2.1</u>: \(ğ¿ğ¹ğ´ âˆˆ P^{\text{NP}}\):
Given an instance \((ğ¶_1, ğ¶_2)\), call the \(\text{NP}\) oracle to determine the first lexicographically first string \(ğ‘¥ âˆˆ \{0, 1\}^ğ‘›\) that is accepted by \(ğ¶_1\). The \(\text{NP}\) oracle nondeterministically evaluates each string with \(ğ¶_1\) but uses an arbitrary enumeration scheme to prioritize which string that is accepted by \(ğ¶_1\) is lexicographically first. If there is no such string, the machine returns false. 

If \(âˆƒ\) a lexicographically-first string \(x\), the \(P\) machine would check if \(ğ¶_2(ğ‘¥) = 1\):

If \(ğ¶_2(ğ‘¥) = 1\), the \(P\) machine returns ACCEPT.

If \(ğ¶_2(ğ‘¥) = 0\), the \(P\) machine returns REJECT.

QED.


## **Lemma 3: \(\text{P}^{\text{NP}}\subseteq S_2^P\).**

In Lemma 2, I showed that LEXâˆ’FIRSTâˆ’ACCEPTANCE (LFA) \(âˆˆ \text{P}^\text{NP}\)-complete. Therefore, to show that \(P^\text{NP} âŠ† ğ‘†_2^P\), we can instead just show that \(\text{LFA} âˆˆ S_2^P\) since \(\text{LFA}\) can then be generalized to all other languages in \(ğ‘ƒ^{\text{NP}}\). Therefore, our goal is to show that for some predicate \(T\):

$$1) âˆ€ğ‘¥âˆˆ\text{LFA}, âˆƒğ‘¦âˆ€ğ‘§, ğ‘‡(ğ‘¥,ğ‘¦,ğ‘§)=1$$
$$2) âˆ€ğ‘¥âˆ‰\text{LFA}, âˆƒğ‘§âˆ€ğ‘¦, ğ‘‡(ğ‘¥,ğ‘¦,ğ‘§)=0$$

Given an instance \((ğ¶_1, ğ¶_2)\) of \(\text{LFA}\), we let \(ğœ™(ğ‘¥, ğ‘¦)\) be the lexicographically-first string (to be accepted by circuit \(ğ¶_1\)) between \(x\) and \(y\). Therefore, we define the following predicate \(T\):
\(ğ‘‡(ğ‘¥, ğ‘¦, ğ‘§) = ğ¶_2(ğœ™(ğ‘¥, ğ‘¦))\).

In the case that \(ğ¶_1(ğ‘¥)\) and \(ğ¶_1(ğ‘¦)\) are both \(0\), there is no lexicographically-first string. In this case, we simply set \(ğ‘‡(ğ‘¥, ğ‘¦, ğ‘§) = 0\). However, we can rewrite this as:

$$(ğ¶_1,ğ¶_2) âˆˆ \text{LFA} \Rightarrow âˆƒyâˆ€z(âˆ€x), T(x,y,z) = 1 \Rightarrow âˆƒyâˆ€x, T(x,y)=1$$
$$(ğ¶_1,ğ¶_2) âˆ‰ \text{LFA} \Rightarrow âˆƒzâˆ€y(âˆ€x), T(x,y,z) = 0 \Rightarrow âˆƒxâˆ€y, T(x,y)=0$$

Since this is the definition of \(ğ‘†_2^ğ‘ƒ\) (modified from above), this implies that \(\text{LFA} âˆˆ ğ‘†_2^ğ‘ƒ\). Hence, by the \(\text{P}^{\text{NP}}\)-completeness of \(\text{LFA}\), we have that: 

$$\text{P}^{\text{NP}} âŠ† ğ‘†_2^P$$

QED.



## **Lemma 4: \(\text{MA} \subseteq S_2^P\).


\(âˆ€ ğ¿_1 âˆˆ \text{MA}\), we have by definition that:

$$ğ‘¥ âˆˆ ğ¿_1 â‡’ âˆƒğ‘¦, \Pr\limits_z [(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¥\frac{2}{3}$$

$$ğ‘¥ âˆ‰ ğ¿_1 â‡’ âˆ€ğ‘¦, \Pr\limits_z [(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¤\frac{1}{3}$$

\(âˆ€ ğ¿_2 âˆˆ ğ‘†_2^P\), we have by definition that:

$$ğ‘¥ âˆˆ ğ¿_2 â‡’ âˆƒğ‘¦âˆ€ğ‘§, (ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…$$

$$ğ‘¥ âˆ‰ ğ¿_2 â‡’ âˆƒğ‘§ âˆ€ğ‘¦, (ğ‘¥,ğ‘¦,ğ‘§)âˆ‰ğ‘…$$

We can increase the probability of successfully accepting a â€œyesâ€ instance through error reduction, from which we know that \(âˆ€ ğ¿_1 âˆˆ \text{MA}, âˆƒğ‘… âˆˆ P\) such that:

$$ğ‘¥ âˆˆ ğ¿_1 â‡’ âˆƒğ‘¦, \Pr\limits_z[(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]=1$$

$$ğ‘¥ âˆ‰ ğ¿_1 â‡’ âˆ€ğ‘¦, \Pr\limits_z[(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¤\frac{1}{3}$$

Similarly, we can successfully decrease the probability of incorrectly accepting a â€œnoâ€ instance through repeated error reduction which reduces the probability to:

$$ğ‘¥ âˆˆ ğ¿_1 â‡’ âˆƒğ‘¦, \Pr\limits_z[(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]=1$$

$$ğ‘¥ âˆ‰ ğ¿_1 â‡’ âˆ€ğ‘¦, \Pr\limits_z[(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¤ \frac{1}{2^{|ğ‘¦|}}$$

We claim then through these definitions that \(âˆ€ğ¿ âˆˆ \text{MA}, ğ¿ âˆˆ ğ‘†_2^P\). To show that \(ğ‘¥ âˆˆ ğ¿ â‡’ âˆƒğ‘¦, \Pr\limits_z[(ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…] = 1\) is contained in \(ğ‘¥ âˆˆ ğ¿_2 â‡’ âˆƒğ‘¦ âˆ€ğ‘§, (ğ‘¥, ğ‘¦, ğ‘§) âˆˆ ğ‘…\): Since the probability of \((ğ‘¥, ğ‘¦, ğ‘§) âˆˆ R\) is \(1\) for all \(z\):

$$ğ‘¥ âˆˆ ğ¿_1 â‡’ âˆƒğ‘¦, \Pr\limits_z [(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]=1$$

$$ â‡’ ğ‘¥ âˆˆ ğ¿_2 â‡’ âˆƒğ‘¦ âˆ€ğ‘§, (ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…$$

Using Booleâ€™s inequality, we can take the union bound of the probability of incorrectly accepting a â€œnoâ€ instance of \(L\) across all possible values of \(y\) to get:

$$ğ‘¥ âˆ‰ ğ¿_1 â‡’ âˆ€ğ‘¦, \Pr\limits_z [(ğ‘¥,ğ‘¦,ğ‘§)âˆˆğ‘…]â‰¤ \frac{1}{2^{|y|}}$$

$$âˆˆ âˆƒğ‘¦ \text{ such that }\Pr\limits_z [(x, y, z)âˆˆğ‘…] â‰¤ \frac{1}{2^{|y|}}\times 2^{|y|}$$

$$= âˆƒğ‘¦ \text{ such that }\Pr\limits_z [(x, y, z)âˆˆğ‘…] =1$$

$$âˆˆ âˆƒ ğ‘§ \text{ such that } âˆ€y(x, y, z)âˆ‰ğ‘…$$

$$ğ‘¥ âˆ‰ L_2 â‡’ âˆƒğ‘§ âˆ€y, (x, y, z) âˆ‰ ğ‘…$$

These equations fits the necessary condition for all languages in \(ğ‘†_2^P\). Therefore, we have that:

$$âˆ€ ğ¿ âˆˆ \text{MA}, \text{MA} âˆˆ ğ‘†_2^P$$

$$\text{MA} âŠ† ğ‘†_2^P$$

QED.



## **Lemma 5: \(\text{BPP} \subseteq S_2^P\).**


Lemma \(1\): \(\text{BPP} âŠ† \text{MA}\)

Given an arbitrary language \(\text{L} \in \text{BPP}\), we can show that there is an \(\text{MA}\) protocol that decides an instance \(x\):


Merlin (the prover) sends a single TRUE (\(1\)) bit (This is just a filler so that Merlin is doing something)


Arthur (the verifier) disregards Merlinâ€™s bit and simulates the \(\text{BPP}\) machine for \(L\) on \(x\).

Note here that this is only possible since Arthur has the ability to flip coins and make random decisions.

If the \(\text{BPP}\) machine returns â€œTRUEâ€, Arthur returns â€œTRUEâ€.

If the BPP machine returns â€œFALSEâ€, Arthur returns â€œFALSEâ€.


Completeness and Soundness are intact here because Arthur simulates the \(\text{BPP}\) machine which has the same probabilities:

In particular, \(âˆ€ğ‘¥ âˆˆ L\), \(\Pr[ğ‘¥ \text{ accepted}] â‰¥ \frac{2}{3}\) and \(âˆ€ğ‘¥ âˆ‰ L\), \(\Pr[ğ‘¥ \text{ rejected}] â‰¥ \frac{2}{3}\).


Therefore, any language in \(\text{BPP}\) has an \(\text{MA}\) protocol that decides it. Hence, \(\text{BPP} âŠ† \text{MA}\).

QED.


Therefore, since we know that \(\text{BPP} âŠ† \text{MA}\), we can use the transitivity property and the result proven in Lemma 4 to obtain:

$$\text{BPP} âŠ† \text{MA} âŠ† S_2^P$$

From this, we have that \(\text{BPP} âŠ† S_2^P\).

QED.


## **Lemma 6: If SAT has polynomial-sized circuits, then \(\text{PH} = S_2^P\).**


It is known from the Cook-Levin theorem that \(\text{SAT} âˆˆ \text{NP-complete}\). Therefore, if \(\text{SAT}\) has polynomial-size circuits, then:

$$ \text{NP} \subseteq \text{P}/\text{poly}$$

To show that \(\text{PH} = S_2^P\), we need to show that:
1) \(\text{PH} = \Sigma_2^P\)
2) \(\text{PH} = \Pi_2^P\)

In Lemma \(1\), we showed that \(\text{PH} \subseteq \Sigma_2^P \cap \Pi_2^P\). Therefore, the onus of this proof is to show that:
1) \(\Sigma_2^P âŠ† \text{PH}\)
2) \(\Pi_2^P âŠ† \text{PH}\)

<u>Sub-Lemma 6.1</u>: \(\Sigma_2^ğ‘ƒ = \text{PH}\)

This follows from the regular Karp-Lipton theorem shown in Lemma 4.


Therefore, \(\Sigma_2^ğ‘ƒ âŠ† \text{PH}\) is trivially true.


QED.

<u>Sub-Lemma 6.2</u>: \(\Pi_2^P âŠ† \text{PH}\):

Let \(ğ¶\) be a family of circuits which output \(1\) on satisfiable inputs and \(0\) on unsatisfiable inputs.

Let \(C'\) be the family of circuits using self-reducibility of \(\text{SAT}\) instances to output satisfying assignments for \(\text{SAT}\) formulas.


Let \(L\) be an arbitrary language in \(\Pi_2^P\) and let \(ğœ™\) be a predicate in \(P\). It follows then that:s

$$ğ‘¥âˆˆğ¿ â‡’ âˆ€ğ‘¦âˆƒğ‘§, ğœ™(ğ‘¥,ğ‘¦,ğ‘§)=1$$

$$ğ‘¥âˆ‰ğ¿ â‡’ âˆƒğ‘¦âˆ€ğ‘§, ğœ™(ğ‘¥,ğ‘¦,ğ‘§)=0$$


However, note here that \(\{(ğ‘¥, ğ‘¦) | âˆƒğ‘§, Ï†(x, y, z) = 1\}\) is by definition in \(\text{NP}\) (where \(z\) is a witness).


Therefore, \(C'\) must exist to find satisfying assignments \(z\) for satisfying formulas \(x\).


We define the predicate \(ğœ™'\) to be the polynomially verifiable instance \((ğ¶, ğ‘¥, ğ‘¦)\).

Note that \((C,x,y)\) is \(\text{TRUE}\) if \(ğ¶'(ğ‘¥) = ğ‘§\), where \(ğœ™(ğ‘¥, ğ‘¦, ğ‘§) = 1\), and \(\text{FALSE}\) otherwise. 


Therefore,
$$ğ‘¥âˆˆğ¿â‡’ âˆƒğ¶ \text{ such that }âˆ€ğ‘¦, ğ¶'(ğ‘¥)=ğ‘§ \text{ such that } ğœ™'(ğ‘¥,ğ‘¦,ğ‘§)=1$$
$$ğ‘¥âˆ‰ğ¿â‡’ âˆ€ğ¶ \text{ such that }âˆƒğ‘¦ âˆ€ğ‘§, ğ¶'(ğ‘¥)=ğ‘§ \text{ such that } ğœ™'(ğ‘¥,ğ‘¦,ğ‘§)=0$$


However, this can just be rewritten as:

$$ğ‘¥âˆˆğ¿ â‡’ âˆƒğ¶âˆ€ğ‘¦, ğœ™'(ğ¶,ğ‘¥,ğ‘¦)=1$$

$$ğ‘¥âˆ‰ğ¿ â‡’ âˆƒğ‘¦âˆ€ğ¶, ğœ™'(ğ¶,ğ‘¥,ğ‘¦)=0$$


Therefore, by definition \(ğ¿ âˆˆ S_2^ğ‘ƒ\). Since \(L âˆˆ \Pi_2^P\), we have that \(\Pi_2^P âŠ† S_2^P\).


QED.

Therefore, since we have shown that

$$\Sigma_2^P âŠ† \text{PH},\quad \Pi_2^P âŠ† \text{PH},$$

and since we already know that

$$\text{PH} âŠ† \Sigma_2^ğ‘ƒ âˆ© \Pi_2^P,$$

we now have that

$$\text{PH} = \Sigma_2^P \text{ and } \text{PH} = \Pi_2^ğ‘ƒ.$$

Therefore,

$$S_2^P = \Pi_2^P = \Sigma_2^P.$$

This gives us:

$$\text{PH} = S_2^P$$

QED.